Script started on Wed 31 Oct 2018 11:13:20 PM EDT
[?1034hbash-4.2$ uname -a
Linux zeus-1 3.10.0-862.14.4.el7.x86_64 #1 SMP Wed Sep 26 15:12:11 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux
bash-4.2$ pwd
/home/aveney2/CS262/Project2_aveney2_201
bash-4.2$ ls
cs262.pgm  half.pgm  image.c  image.h  Makefile  pl.c  pl.txt  Project2Typescript_aveney2_201  stego.c	Stego.c  StegoExtract.c
bash-4.2$ make Stego
gcc -c Stego.c
gcc -c image.c
gcc -g -Wall -O2 -o Stego Stego.o image.o -lm
bash-4.2$ make StegoExtract.c [K[K[K[C[C
gcc -c StegoExtract.c
gcc -g -Wall -O2 -o StegoExtract StegoExtract.o image.o -lm
bash-4.2$ Stego

Stego <key> <cover_file> <stego_file> <file_to_hide> 
bash-4.2$ Stego 7630 half.pgm payload[K[K[K[K[K[Kay[K[K[Kstego.c pl.c 

Reading input file 'half.pgm'

Reading binary file 'pl.c'

Writing file 'stego.c'
bash-4.2$ StegoExtract 

StegoExtract <key> <stego_file> <file_to_extract> 
bash-4.2$ StegoExtract 7630 stego.c extract.c

Reading input file 'stego.c'
Size of stego.c: 8694 
GNUMBER: 677630 

Writing file 'extract.c'
bash-4.2$ diff pl.c extract.c 
bash-4.2$ diff pl.c extract.c [C[C[C[C[C[C[C[C[C[CStegoExtract 7630 stego.c extract.c[K[20@ 7630 half.pgm stego.c pl.c[C[1P[1@p[1@g[1@m[C[C[C[C[C[1P t x t 

Reading input file 'half.pgm'

Reading binary file 'pl.txt'

Writing file 'stego.pgm'
bash-4.2$ Stego 7630 half.pgm stego.pgm pl.txt [C[C[C[C[C[C[C[C[C[C[17Pdiff pl.c extract.c[C[C[C[C[C[C[C[C[C[C[CStegoExtract 7630 stego.c extract.c[1P extract.cp extract.cg extract.cm extract.c[C[C[C[C[C[C[C[C[C[C[K[K[K[K[K[K[K[K[Kextract.txt

Reading input file 'stego.pgm'
Size of stego.pgm: 1025 
GNUMBER: 677630 

Writing file 'extract.txt'
bash-4.2$ diff pl.txt extract.txt 
bash-4.2$ Stego[K[K[K[K[Kdiff pl.txt extract.txt [C[C[C[C[C[C[C[C[C[CStegoExtract 7630 stego.pgm extract.txt[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[2P 7630 half.pgm stego.pgm pl.txt [C[C[C[C[C[C[C[C[C[C[17Pdiff pl.c extract.c[C[C[C[C[C[C[C[C[C[C[C[17@Stego 7630 half.pgm stego.pgm pl.txt[C[C[C[C[C[C[C[C[C[C[C[C[C[1P[1P[1P[1P[1P[1P[1P[1P[1@c[1@s[7@262.pgm[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C

Reading input file 'cs262.pgm'

Reading binary file 'pl.txt'

Writing file 'stego.pgm'
bash-4.2$ Stego 7630 cs262.pgm stego.pgm pl.txt [C[C[C[C[C[C[C[C[C[C[14Pdiff pl.txt extract[C[C[C[C[C[C[C[C[C[C[C[C[C[C[CStegoExtract 7630 stego.pgm extract.txt[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[2P 7630 half.pgm stego.pgm pl.txt [C[C[C[C[C[C[C[C[C[C[C[C[C[C[CExtract 7630 stego.pgm extract.txt[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[2P 7630 half.pgm stego.pgm pl.txt [C[C[C[C[C[C[C[C[C[C[C[C[C[C[CExtract 7630 stego.pgm extract.txt

Reading input file 'stego.pgm'
Size of stego.pgm: 1025 
GNUMBER: 677630 

Writing file 'extract.txt'
bash-4.2$ diff pl.txt extract..[Ktxt 
bash-4.2$ diff pl.txt extract.txt [C[C[C[C[C[C[C[C[C[CStegoExtract 7630 stego.pgm extract.txt[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1P 7630 cs262.pgm stego.pgm pl.txt [C[C[C[C[C[C[C[C[C[C[14Pdiff pl.txt extract[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[14@Stego 7630 cs262.pgm stego.pgm pl[C[C[C[C[C[1P[1P[1P[1@t[1@x[1@t[C[1@ 

Reading input file 'cs262.pgm'

Reading binary file 'pl.txt'

Writing file 'stego.txt'
bash-4.2$ Stego 7630 cs262.pgm stego.txt  pl.txt [C[C[C[C[C[C[C[C[C[C[15Pdiff pl.txt extract[C[C[C[C[C[C[C[C[C[C[C[C[C[C[CStegoExtract 7630 stego.pgm extract.txt[C[C[1P extract.txt[1P extract.txt[1P extract.txtt extract.txtx extract.txtt extract.txt[C[C[C[C[C[C[C[C[C[C1.txt

Reading input file 'stego.txt'
Size of stego.txt: 1025 
GNUMBER: 677630 

Writing file 'extract1.txt'
bash-4.2$ diff pl.txt extract1.txt 
bash-4.2$ Stego[K[K[K[K[Kdiff pl.txt extract1.txt [C[C[C[C[C[C[C[C[C[CStegoExtract 7630 stego.txt extract1.txt[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1P 7630 cs262.pgm stego.txt  pl.txt [C[C[C[C[C[C[C[C[C[C[15Pdiff pl.txt extract[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[15@Stego 7630 cs262.pgm stego.txt  pl[C[C[C[C[C[C[C[1P[1P[1P[1P[1P[1P[1P[1P[1P[1@p[1@l[1@.[1@c[1P[1P[1P[1P[1@s[1@t[1@e[1@g[1@o[1@.[1@c[C[C[C[C[C[C[C[C[1P [1P [1P [1P [1P [1P [K[1P[1@t[1@x[1@t[C[C [1@s[1P[1@p[1@l[1@.[1@c

Reading input file 'cs262.pgm'

Reading binary file 'pl.c'

Writing file 'stego.txt'
bash-4.2$ Stego 7630 cs262.pgm stego.txt pl.c  [C[C[C[C[C[C[C[C[C[C[12Pdiff pl.txt extract1.txt[C[C[C[C[C[C[C[C[C[C[CStegoExtract 7630 stego.txt extract1.txt[C[C[C[C[C[C[C[C[C[C[C[K[K[K[K[K[K[K[K[K[K[K[Kes[K[Kout.c

Reading input file 'stego.txt'
Size of stego.txt: 8694 
GNUMBER: 677630 

Writing file 'out.c'
bash-4.2$ diff pl.c out.c
bash-4.2$ cat Stego.c
// Alexandra Veney G00677630
// CS 262 Lab Section 201
// Project 2


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
 * Stego.c: A program for manipulating images                           *
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


#include <stdio.h>
#include <string.h>
#include "image.h"
#include <math.h>
#define  GNUMBER 677630 




// randperm function
void randperm(int a[], int n);

// scramble data function
void scrambledata(int a[], struct Buffer in, struct Buffer out);

// modify lsbs
byte setlsbs(void *other, int opt, byte cover, int pos);

// allocate memory and check success
void* allocate(int s, int opt);


int main(int argc, char *argv[]){

	int i, j, k, cover_bits, bits;
	struct Buffer b = {NULL, 0, 0}, sb = {NULL, 0, 0};
	struct Image img = {0, NULL, NULL, NULL, NULL, 0, 0};
	byte b0;

	if (argc != 5) 
	{
		printf("\n%s <key> <cover_file> <stego_file> <file_to_hide> \n", argv[0]);
		exit(1);
	}



	//READ FILES/SEED RNG-----------------------------------------------------//
	// Initialize RNG with command line seed 
	int  seed = atoi(argv[1]);	
	srandom(seed);

	// Read image file(cover) into the image buffer img
	ReadImage(argv[2],&img);     

	// Read binary data(payload)
	ReadBinaryFile(argv[4],&b);   


	// Hidden information 
	if (!GetColor)
		cover_bits = img.NofC*img.NofR;
	else 
		cover_bits = 3*img.NofC*img.NofR;    
	bits = (8 + b.size)*8;

	if (bits > cover_bits)
	{
		printf("Cover file is not large enough %d (bits) > %d (cover_bits)\n",bits,cover_bits);
		exit(1);
	}


	//EMBED SIZE----------------------------------------------------------------//
	// Embed size of payload into cover
	// Size bits from R to L are embedded into bytes [0,31] of cover
	for(int i = 0; i < 32; i++){

		int *size;
		size = &b.size;

		byte newByte;

		newByte = setlsbs(size, 1, GetGray(i), i);
		SetGray(i, newByte);
	}


	//EMBED G#------------------------------------------------------------------//
	// Embed G# into cover
	// Eight digit G# embedded (4 bits per digit) from L to R 
	for(int c = 7 ; c >= 0 ; c--){

		static int index = 32;  // counter for coverbyte index [32,63]
		int gDigit;		// gnumber digit being embedded 
		int decPlace;		// *used to help select whole numbers from gnumber
		byte newByte;

		// Get digit of gnumber
		decPlace = pow(10, c);
		gDigit =(GNUMBER / decPlace) % 10;

		// Get bits from digit 
		for(int d = 3; d >= 0 ; d--){

			int *digit;
			digit = &gDigit;

			byte newByte;	
			newByte = setlsbs(digit, 1, GetGray(index), d);

			SetGray(index, newByte);

			index++;

		}
	}



	//PERM---------------------------------------------------------------------//
	// Create permutation of array of indexs [0,(b.size-1)]
	int n = b.size;

	int *a = NULL;
	a = allocate(n, 1);

	for(int i = 0; i < n; i++){

		a[i] = i;
	}


	// Rand perm of a[]
	randperm(a, n);	


	//SCRAMBLE----------------------------------------------------------------//
	// Allocate space and initialize sizefor scramble buffer (sb)
	sb.data = allocate(b.size, 2);

	sb.size = b.size;



	// Scrambled payload bytes
	scrambledata(a, b, sb);


	//EMBED REMAINING BYTES-----------------------------------------------------//
	// Embed information into the image one byte at the time
	for (int i = 0; i<sb.size; i++){		

		static int index = 64; 	// counter for coverbyte index [64,last byte needed]

		byte payloadByte;
		payloadByte = sb.data[i];

		// Embed bit of payload into lsb of each coverbyte	
		for (int j = 7; j >= 0; j--){

			byte *plb;
			plb = &payloadByte;

			byte newByte;	
			// Modified byte to be embeded
			newByte = setlsbs(plb, 2, GetGray(index), j);

			// Set newByte at current index
			SetGray(index, newByte);

			// Increment counter to move to next cover byte
			index++;
		}	

	}

	WriteImage(argv[3],img);  // output stego file (cover_file + file_to_hide)

	// Free all dynamically allocated memory
	free(b.data);
	free(sb.data);
	free(img.gray);
	free(a);

}


// Creates permutation of array of ints
void randperm(int a[], int n){

	for(int y = n-1; y >= 0; y--){

		int temp;
		int randomIndex;

		temp = a[y];
		randomIndex= random() % (y + 1);
		a[y] = a[randomIndex];
		a[randomIndex] = temp; 
	}

}

// Scrambles data according to random permutation
void scrambledata(int a[], struct Buffer in, struct Buffer out){

	for(int i = 0; i < in.size; i++){
		out.data[i] = in.data[a[i]];
	}

}

// Sets the LSB of cover byte 
//other: info to be embedded
//opt  : cast options for comparison  int* or byte* 
//cover: orig. coverbyte 
//pos  : index of bit to be embedded
byte setlsbs(void *other, int opt, byte cover, int pos){

	int bit;	 // bit to embed
	int lsb;	 // lsb of cover byte
	long  position;
	byte newByte;		

	// Get specific bit at position
	position = pow(2,pos); // 1, 2, 4, 8, 16 ....

	// Cast void* based on opt
	// opt 1: int   opt 2:byte	
	if(opt == 1){
		bit = (*((int*)other) & position)? 1 : 0;
	}
	else if(opt == 2){
		bit = (*((byte*)other) & position)? 1 : 0;
	}

	// Get lsb of cover byte
	lsb = (cover & 0x01)? 1 : 0;

	//Set newByte for cover
	newByte  = (bit != lsb)? (cover ^ 0x01): cover;		

	return newByte;	


}

// Allocates memory and checks success
void* allocate(int s, int opt){

	void* location = NULL;

	// Cast void* based on opt
	// opt 1: int   opt 2:byte	
	if(opt == 1){
		location = (int*)malloc(sizeof(int)*s);
	}else if(opt == 2){
		location = (byte*)malloc(sizeof(byte)*s);
	}

	if(location == NULL){
		printf("Not enough memory, malloc failed\n");
		exit(1);
	}

	return location;
}

bash-4.2$ cat StegoExtract.c
// Alexandra Veney G00677630
// CS 262 Lab Section 201
// Project 2

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
 * StegoExtract.c: A program for manipulating images                    *
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

#include <string.h>
#include "image.h"
#include <math.h>



// Creates permutation of array of ints
void randperm(int *a, int n);

// Unscrambles data according to random permutation
void unscramble(int a[], struct Buffer in, struct Buffer out);

// Allocates memory and checks success
void* allocate(int s, int opt);

// Gets LSBs of stego file 
int getlsbs(byte cover);


int main(int argc, char *argv[]){ 
	int i, j, k, cover_bits, bits;
	struct Buffer b = {NULL, 0, 0}, ub = {NULL, 0, 0};   // need to buffers
	struct Image img = {0, NULL, NULL, NULL, NULL, 0, 0};
	byte b0;

	if (argc != 4) 
	{
		printf("\n%s <key> <stego_file> <file_to_extract> \n", argv[0]);
		exit(1);
	}


	//READ FILES/SEED RNG----------------------------------------------------//
	// Initialize random number generator
	int seed = atoi(argv[1]);
	srandom(seed);


	ReadImage(argv[2],&img);       // read image file into the image buffer img
	// the image is an array of unsigned chars (bytes) of NofR rows
	// NofC columns, it should be accessed using provided macros

	// hidden information 
	// first four bytes is the size of the hidden file
	// next 4 bytes is the G number (4 bits per digit)
	if (!GetColor)
		cover_bits = img.NofC*img.NofR;
	else 
		cover_bits = 3*img.NofC*img.NofR;    

	b.size = 0;

	//EXTRACT SIZE----------------------------------------------------------//
	// Extract four size bytes for the Buffer's size field
	for(int i = 31; i >= 0; i--){

		// Get LSB of cover byte
		// Add lsb to size 
		b.size = ((b.size << 1) | getlsbs(GetGray(i)));

	}

	printf("Size of %s: %d \n", argv[2], b.size);

	// Allocates memory and checks success
	b.data = allocate(b.size, 2);



	//EXTRACT GNUMBER------------------------------------------------------//
	int gnumber =0;

	// Extract the eight digits of your G# using 4 bits per digit
	for(int c = 7; c >= 0; c--){

		static int index = 32;	 // index/counter of cover byte [32,63]
		long decPlace;		 // *used to place gnumber digit in correct position
		int digit = 0;		 // the digit extracted from bytes
		int lsb;

		for(int d = 0; d <= 3; d++){

			// Get lsb of cover byte
			// Add lsb to end of digit
			digit = ((digit << 1) | getlsbs(GetGray(index)));

			// Move to next cover byte 
			index++;
		}

		decPlace = pow(10, c);
		digit *=  decPlace;
		gnumber +=  digit;	
	}

	printf("GNUMBER: %d \n", gnumber);

	//EXTRACT PAYLOAD  BYTES------------------------------------------------------//
	for (i=0; i<b.size; i++)
	{
		static int index = 64;
		// here you extract information from the image one byte at the time
		static byte payloadByte;

		payloadByte = 0;
		for(int j = 0; j <=7; j++){

			// Get lsb of stego image byte
			//printf("LSB of byte %d\n", lsb);
			payloadByte <<= 1;

			if(getlsbs(GetGray(index)) != 0){

				payloadByte ^= 0x01;
			}

			index++;

		}

		b.data[i] = payloadByte;


	}

	//PERM------------------------------------------------------------------------------//
	// Array of index (0 to size)
	int *a = NULL;
	a = allocate(b.size, 1);


	for(int c = 0; c < b.size; c++){
		a[c] = c;
	}	

	randperm(a, b.size);

	//UNSCRAMBLE------------------------------------------------------------------------//
	// Unscramble the data:   b to ub
	ub.size = b.size;
	ub.data = allocate(b.size, 1);


	unscramble(a, b, ub);

	WriteBinaryFile(argv[3],ub);  // output payload file




}


// Creates permutation of array of ints
void randperm(int *a, int n){

	for (int y = (n-1); y >= 0 ; y--){

		int temp;
		int randomIndex;

		temp = a[y];;
		randomIndex = random() % (y + 1);
		a[y] = a[randomIndex];
		a[randomIndex] = temp;
	} 


}

// Unscrambles data according to random permutation
void unscramble(int a[], struct Buffer in, struct Buffer out){

	for(int i = 0; i < in.size; i++){

		out.data[a[i]] = in.data[i];
	} 
}


// Allocates memory and checks success
void* allocate(int s, int opt){

	void* location = NULL;

	// Cast void* based on opt
	// opt 1: int   opt 2:byte	
	if(opt == 1){
		location = (int*)malloc(sizeof(int)*s);
	}else if(opt == 2){
		location = (byte*)malloc(sizeof(byte)*s);
	}

	if(location == NULL){
		printf("Not enough memory, malloc failed\n");
		exit(1);
	}
	return location;
}


// Get  LSBs of stego file 
int  getlsbs(byte cover){

	int lsb;         // lsb of cover byte

	// Get lsb byte
	lsb = (cover & 0x01)? 1 : 0;

	return lsb;


}








bash-4.2$ exit

Script done on Wed 31 Oct 2018 11:25:15 PM EDT
